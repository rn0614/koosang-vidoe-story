import React, { useRef, useReducer, useMemo, useCallback } from 'react';
import { Box, Text } from '@react-three/drei';
import { useFrame, ThreeEvent } from '@react-three/fiber';
import { Mesh, Vector3 } from 'three';
import { BoxMethods } from '@/entities/box/types';
import { useContainerStore } from '@/entities/container';
import { BoxPhysics } from '@/entities/box/model/physics';

interface AnimatedBoxProps {
  boxId: string;
  onSelect: (boxId: string) => void;
}

type MovePhase = 'idle' | 'to_conveyor' | 'on_conveyor' | 'dropping';

interface MoveState {
  targetPosition: [number, number, number];
  isAnimating: boolean;
  isSequentialMoving: boolean;
  movementPhase: MovePhase;
  finalTargetX: number;
  finalTargetZ: number;
  sequentialResolve: (() => void) | null;
}

type MoveAction =
  | { type: 'SET_TARGET_POSITION'; payload: [number, number, number] }
  | { type: 'SET_ANIMATING'; payload: boolean }
  | { type: 'START_SEQUENTIAL'; x: number; z: number; resolve: () => void }
  | { type: 'SET_PHASE'; phase: MovePhase }
  | { type: 'END_SEQUENTIAL' }
  | { type: 'SET_RESOLVE'; resolve: (() => void) | null };

const initialMoveState: MoveState = {
  targetPosition: [0, 0, 0],
  isAnimating: false,
  isSequentialMoving: false,
  movementPhase: 'idle',
  finalTargetX: 0,
  finalTargetZ: 0,
  sequentialResolve: null,
};

function moveReducer(state: MoveState, action: MoveAction): MoveState {
  switch (action.type) {
    case 'SET_TARGET_POSITION':
      return { ...state, targetPosition: action.payload, isAnimating: true };
    case 'SET_ANIMATING':
      return { ...state, isAnimating: action.payload };
    case 'START_SEQUENTIAL':
      return {
        ...state,
        isSequentialMoving: true,
        movementPhase: 'to_conveyor',
        finalTargetX: action.x,
        finalTargetZ: action.z,
        sequentialResolve: action.resolve,
      };
    case 'SET_PHASE':
      return { ...state, movementPhase: action.phase };
    case 'END_SEQUENTIAL':
      return {
        ...state,
        isSequentialMoving: false,
        movementPhase: 'idle',
        sequentialResolve: null,
      };
    case 'SET_RESOLVE':
      return { ...state, sequentialResolve: action.resolve };
    default:
      return state;
  }
}

const AnimatedBoxComponent: React.FC<AnimatedBoxProps> = ({
  boxId,
  onSelect,
}) => {
  console.log(`üîÑ AnimatedBox ${boxId} Î†åÎçîÎßÅ`);
  const handleCardClick = useCallback(
    (e: ThreeEvent<MouseEvent>) => {
      e.stopPropagation();
      console.log(`üéØ ${boxId} Ïπ¥Îìú ÌÅ¥Î¶≠`);
      onSelect(boxId);
    },
    [onSelect, boxId],
  );

  // üöÄ ÌïµÏã¨ ÏµúÏ†ÅÌôî: Ïù¥ Î∞ïÏä§Ïùò Îç∞Ïù¥ÌÑ∞Îßå Íµ¨ÎèÖ (ÌöåÏ†ÑÍ∞í Ìè¨Ìï®)
  const boxData = useContainerStore(
    useCallback((state) => state.boxes.get(boxId), [boxId]),
  );

  // üöÄ ÏÑ†ÌÉù ÏÉÅÌÉúÎßå Î≥ÑÎèÑ Íµ¨ÎèÖ
  const isSelected = useContainerStore(
    useCallback((state) => state.selectedBoxId === boxId, [boxId]),
  );

  // üöÄ Ïä§ÌÜ†Ïñ¥ Î©îÏÑúÎìúÎì§ÏùÄ Ìïú Î≤àÎßå Í∞ÄÏ†∏Ïò§Í∏∞ (Î¶¨Î†åÎçîÎßÅÍ≥º Î¨¥Í¥Ä)
  const { updateBoxPosition } = useContainerStore.getState();

  const meshRef = useRef<Mesh>(null);

  // Î∞ïÏä§ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÏùå
  if (!boxData) {
    console.log(`‚ùå AnimatedBox ${boxId}: Î∞ïÏä§ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå`);
    return null;
  }

  // useReducerÎ°ú Ïù¥Îèô Í¥ÄÎ†® ÏÉÅÌÉú ÌÜµÌï©
  const [moveState, dispatch] = useReducer(moveReducer, {
    ...initialMoveState,
    targetPosition: [boxData.x, boxData.y, boxData.z],
  });

  // üéØ stabilityInfoÎäî useMemoÎ°ú Í≥ÑÏÇ∞ (Î∞ïÏä§ ÏúÑÏπò/ÌÅ¨Í∏∞ Î≥ÄÍ≤ΩÏãúÏóêÎßå Ïû¨Í≥ÑÏÇ∞)
  const stabilityInfo = useMemo(() => {
    console.log(`üîç ${boxId} ÏïàÏ†ïÏÑ± Í≤ÄÏÇ¨ Ïû¨Í≥ÑÏÇ∞`);
    const allBoxes = useContainerStore.getState().boxes;
    return BoxPhysics.checkBoxStability(
      boxData.x,
      boxData.y,
      boxData.z,
      boxData.lenX,
      boxData.lenY,
      boxData.lenZ,
      allBoxes,
      boxData.id,
    );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    boxData.x,
    boxData.y,
    boxData.z,
    boxData.lenX,
    boxData.lenY,
    boxData.lenZ,
    boxData.id,
    // checkBoxStability Ìï®Ïàò Ï∞∏Ï°∞ Ï†úÏô∏
  ]);

  // Î∞ïÏä§ Ï§ëÏã¨ Ï¢åÌëú Í≥ÑÏÇ∞ (Î†åÎçîÎßÅÏö©)
  const centerX = boxData.x - boxData.lenX / 2;
  const centerY = boxData.y - boxData.lenY / 2;
  const centerZ = boxData.z - boxData.lenZ / 2;
  
  // ÌöåÏ†ÑÍ∞í Í≥ÑÏÇ∞ (ÎèÑ ‚Üí ÎùºÎîîÏïà)
  const rotationX = (boxData.rotX || 0) * (Math.PI / 180);
  const rotationY = (boxData.rotY || 0) * (Math.PI / 180);
  const rotationZ = (boxData.rotZ || 0) * (Math.PI / 180);

  // Î∞ïÏä§ Îç∞Ïù¥ÌÑ∞Í∞Ä Î≥ÄÍ≤ΩÎêòÎ©¥ targetPosition ÏóÖÎç∞Ïù¥Ìä∏
  React.useEffect(() => {
    console.log(
      `üìç ${boxId} ÏúÑÏπò ÎèôÍ∏∞Ìôî: (${boxData.x}, ${boxData.y}, ${boxData.z})`,
    );
    dispatch({
      type: 'SET_TARGET_POSITION',
      payload: [boxData.x, boxData.y, boxData.z],
    });
  }, [boxData.x, boxData.y, boxData.z, boxId]);

  // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å Í∞êÏßÄ Î∞è ÏãúÌÄÄÏÖú Ïù¥Îèô Îã®Í≥Ñ Ï≤òÎ¶¨
  React.useEffect(() => {
    if (!moveState.isAnimating && moveState.isSequentialMoving) {
      handleMovementPhaseComplete();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [moveState.isAnimating, moveState.isSequentialMoving]); // handleMovementPhaseComplete ÏùòÏ°¥ÏÑ± Ï†úÏô∏

  // ÏãúÌÄÄÏÖú Ïù¥Îèô Îã®Í≥ÑÎ≥Ñ Ï≤òÎ¶¨
  const handleMovementPhaseComplete = useCallback(() => {
    switch (moveState.movementPhase) {
      case 'to_conveyor': {
        dispatch({ type: 'SET_PHASE', phase: 'on_conveyor' });
        const conveyorY = 15;
        const allBoxes = useContainerStore.getState().boxes;
        const targetOnConveyor = BoxPhysics.findNearestAvailablePosition(
          moveState.finalTargetX,
          conveyorY,
          moveState.finalTargetZ,
          boxData.lenX,
          boxData.lenY,
          boxData.lenZ,
          allBoxes,
          boxData.id,
        );
        moveToPosition(
          targetOnConveyor.x,
          targetOnConveyor.y,
          targetOnConveyor.z,
        );
        break;
      }
      case 'on_conveyor': {
        dispatch({ type: 'SET_PHASE', phase: 'dropping' });
        const currentX = moveState.targetPosition[0];
        const currentZ = moveState.targetPosition[2];
        const allBoxes = useContainerStore.getState().boxes;
        const minY = BoxPhysics.findMinimumYPosition(
          currentX,
          currentZ,
          boxData.lenX,
          boxData.lenY,
          boxData.lenZ,
          allBoxes,
          boxData.id,
        );
        moveToPosition(currentX, minY, currentZ);
        break;
      }
      case 'dropping': {
        dispatch({ type: 'END_SEQUENTIAL' });
        if (moveState.sequentialResolve) {
          moveState.sequentialResolve();
        }
        break;
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [moveState.movementPhase, moveState.finalTargetX, moveState.finalTargetZ, moveState.targetPosition, moveState.sequentialResolve, boxData.id, boxData.lenX, boxData.lenY, boxData.lenZ]); // moveState Ï†ÑÏ≤¥ Í∞ùÏ≤¥ Ï†úÏô∏

  // üéØ 3D Ïï†ÎãàÎ©îÏù¥ÏÖò ÌîÑÎ†àÏûÑ Ï≤òÎ¶¨
  useFrame((state, delta) => {
    if (meshRef.current && moveState.isAnimating) {
      const currentPos = meshRef.current.position;
      const targetCenterX = moveState.targetPosition[0] - boxData.lenX / 2;
      const targetCenterY = moveState.targetPosition[1] - boxData.lenY / 2;
      const targetCenterZ = moveState.targetPosition[2] - boxData.lenZ / 2;
      const target = new Vector3(targetCenterX, targetCenterY, targetCenterZ);
      const distance = currentPos.distanceTo(target);

      if (distance > 0.1) {
        currentPos.lerp(target, delta * 3);
      } else {
        currentPos.copy(target);
        dispatch({ type: 'SET_ANIMATING', payload: false });

        // üöÄ Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏: Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å ÌõÑ Ïã§Ï†ú ÏúÑÏπòÎ•º Ïä§ÌÜ†Ïñ¥Ïóê Î∞òÏòÅ
        // Ïä§ÌÜ†Ïñ¥Ïùò ÌòÑÏû¨ Î∞ïÏä§ ÏúÑÏπòÏôÄ ÎπÑÍµêÌïòÏó¨ Ïã§Ï†úÎ°ú Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÏóêÎßå ÏóÖÎç∞Ïù¥Ìä∏
        const [x, y, z] = moveState.targetPosition;
        const currentBoxData = useContainerStore.getState().boxes.get(boxId);
        if (currentBoxData && (currentBoxData.x !== x || currentBoxData.y !== y || currentBoxData.z !== z)) {
          console.log(`üíæ ${boxId} ÏúÑÏπò Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏: (${x}, ${y}, ${z})`);
          updateBoxPosition(boxId, x, y, z);
        }
      }
    }
  });

  // Ïù¥Îèô Î™ÖÎ†π Ìï®ÏàòÎì§
  const moveToPosition = useCallback(
    (x: number, y: number, z: number): void => {
      console.log(`üéØ ${boxId} Ïù¥Îèô Î™ÖÎ†π: (${x}, ${y}, ${z})`);
      dispatch({ type: 'SET_TARGET_POSITION', payload: [x, y, z] });
    },
    [boxId],
  );

  const dropToBottom = useCallback((): void => {
    if (moveState.isSequentialMoving) return;

    const currentX = moveState.targetPosition[0];
    const currentZ = moveState.targetPosition[2];
    const allBoxes = useContainerStore.getState().boxes;
    const minY = BoxPhysics.findMinimumYPosition(
      currentX,
      currentZ,
      boxData.lenX,
      boxData.lenY,
      boxData.lenZ,
      allBoxes,
      boxData.id,
    );
    moveToPosition(currentX, minY, currentZ);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [moveState.isSequentialMoving, moveState.targetPosition[0], moveState.targetPosition[2], boxData.id, boxData.lenX, boxData.lenY, boxData.lenZ]); // Ìï®Ïàò Ï∞∏Ï°∞ Ï†úÏô∏

  const moveToConveyor = useCallback((): void => {
    if (moveState.isSequentialMoving) return;

    const conveyorY = 15;
    const allBoxes = useContainerStore.getState().boxes;
    const conveyorPosition = BoxPhysics.findNearestAvailablePosition(
      boxData.x,
      conveyorY,
      boxData.z,
      boxData.lenX,
      boxData.lenY,
      boxData.lenZ,
      allBoxes,
      boxData.id,
    );
    moveToPosition(conveyorPosition.x, conveyorPosition.y, conveyorPosition.z);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [moveState.isSequentialMoving, boxData.x, boxData.z, boxData.id, boxData.lenX, boxData.lenY, boxData.lenZ]); // Ìï®Ïàò Ï∞∏Ï°∞ Ï†úÏô∏

  const moveToOtherPosition = useCallback(
    (x: number, z: number): Promise<void> => {
      return new Promise((resolve) => {
        dispatch({ type: 'START_SEQUENTIAL', x, z, resolve });
        const conveyorY = 15;
        const allBoxes = useContainerStore.getState().boxes;
        const conveyorPosition = BoxPhysics.findNearestAvailablePosition(
          boxData.x,
          conveyorY,
          boxData.z,
          boxData.lenX,
          boxData.lenY,
          boxData.lenZ,
          allBoxes,
          boxData.id,
        );
        moveToPosition(
          conveyorPosition.x,
          conveyorPosition.y,
          conveyorPosition.z,
        );
      });
      // eslint-disable-next-line react-hooks/exhaustive-deps
    },
    [boxData.x, boxData.z, boxData.id, boxData.lenX, boxData.lenY, boxData.lenZ], // Ìï®Ïàò Ï∞∏Ï°∞ Ï†úÏô∏
  );

  // ref Î©îÏÑúÎìúÎì§ Îì±Î°ù
  React.useImperativeHandle(
    boxData.ref,
    (): BoxMethods => ({
      moveToPosition,
      moveToConveyor,
      dropToBottom,
      moveToOtherPosition,
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [boxId], // Ìï®Ïàò Ï∞∏Ï°∞ ÎåÄÏã† boxIdÎßå ÏùòÏ°¥ÏÑ±ÏúºÎ°ú ÏÑ§Ï†ï
  );

  // ÏÉâÏÉÅ/ÏÉÅÌÉú ÌÖçÏä§Ìä∏ Í≥ÑÏÇ∞
  const getBoxColor = (): string => {
    if (isSelected) return '#ff4444';
    if (moveState.isSequentialMoving) {
      switch (moveState.movementPhase) {
        case 'to_conveyor':
          return '#ffaa00';
        case 'on_conveyor':
          return '#00aaff';
        case 'dropping':
          return '#aa00ff';
        default:
          return '#000000';
      }
    }
    if (!stabilityInfo) return '#000000';
    if (stabilityInfo.isStable) {
      return '#000000';
    } else {
      return '#ff9999';
    }
  };

  const getStatusText = (): string => {
    if (!moveState.isSequentialMoving) return boxData.id;
    switch (moveState.movementPhase) {
      case 'to_conveyor':
        return `${boxData.id} ‚Üë`;
      case 'on_conveyor':
        return `${boxData.id} ‚Üí`;
      case 'dropping':
        return `${boxData.id} ‚Üì`;
      default:
        return boxData.id;
    }
  };

  console.log(`‚úÖ ${boxId} Î†åÎçîÎßÅ ÏôÑÎ£å`);

  return (
    <group>
      <Box
        ref={meshRef}
        position={[centerX, centerY, centerZ]}
        rotation={[rotationX, rotationY, rotationZ]}
        args={[boxData.lenX, boxData.lenY, boxData.lenZ]}
        onClick={handleCardClick}
      >
        <meshStandardMaterial
          color={getBoxColor()}
          transparent
          opacity={isSelected ? 0.8 : 0.7}
        />
      </Box>
      <Text
        position={[centerX, centerY + boxData.lenY / 2 + 0.5, centerZ]}
        fontSize={0.5}
        color="#ffffff"
        anchorX="center"
        anchorY="middle"
      >
        {getStatusText()}
      </Text>
      <Box position={[0, 0, 0]} args={[0.2, 0.2, 0.2]}>
        <meshBasicMaterial color="#00ff00" />
      </Box>
      {stabilityInfo && !moveState.isSequentialMoving && (
        <Text
          position={[
            centerX - boxData.lenX / 2 - 0.5,
            centerY + boxData.lenY / 2 + 0.5,
            centerZ,
          ]}
          fontSize={0.3}
          color={stabilityInfo.isStable ? '#00ff00' : '#ff0000'}
          anchorX="center"
          anchorY="middle"
        >
          {stabilityInfo.isStable ? '‚úì' : '‚ö†'}
        </Text>
      )}
    </group>
  );
};

// üöÄ React.memo ÏµúÏ†ÅÌôî: boxIdÍ∞Ä Í∞ôÏúºÎ©¥ Î¶¨Î†åÎçîÎßÅ Î∞©ÏßÄ
const AnimatedBox = React.memo(AnimatedBoxComponent, (prevProps, nextProps) => {
  const shouldUpdate =
    prevProps.boxId !== nextProps.boxId ||
    prevProps.onSelect !== nextProps.onSelect;

  if (!shouldUpdate) {
    console.log(`üö´ ${prevProps.boxId} Î¶¨Î†åÎçîÎßÅ Î∞©ÏßÄ`);
  }

  return !shouldUpdate;
});

export default AnimatedBox;
